{"ast":null,"code":"// external dependencies\nimport fastStringify from 'fast-stringify'; // constants\n\nimport { CIRCULAR_VALUE, HAS_BUFFER_FROM_SUPPORT, HAS_UINT16ARRAY_SUPPORT, HTML_ELEMENT_REGEXP, ITERABLE_TAGS, OBJECT_CLASS_MAP, OBJECT_CLASS_TYPE_MAP, PRIMITIVE_TAGS, SELF_TAGS, SVG_ELEMENT_REGEXP, TOSTRING_TAGS, TYPEDARRAY_TAGS, UNPARSEABLE_TAGS } from './constants';\nvar charCodeAt = String.prototype.charCodeAt;\nvar toString = Object.prototype.toString;\nvar keys = Object.keys;\n/**\n * @function getFunctionName\n *\n * @description\n * get the name of the function based on a series of fallback attempts\n *\n * @param {function} fn the function to test\n * @returns {string} the function name\n */\n\nexport var getFunctionName = function getFunctionName(fn) {\n  return fn.name || (fn.toString().match(/^\\s*function\\s*([^\\(]*)/i) || [])[1] || 'anonymous';\n};\n/**\n * @function getCircularValue\n *\n * @description\n * get the value used when circular references are found\n *\n * @returns {string} the value for stringification\n */\n\nexport var getCircularValue = function getCircularValue() {\n  return CIRCULAR_VALUE;\n};\n/**\n * @function getIntegerHashValue\n *\n * @description\n * based on string passed, get the integer hash value\n * through bitwise operation (based on spinoff of dbj2\n * with enhancements for reduced collisions)\n *\n * @param {string} string the string to get the hash value for\n * @returns {number} the hash value\n */\n\nexport var getIntegerHashValue = function getIntegerHashValue(string) {\n  var index = string.length,\n      hashA = 5381,\n      hashB = 52711,\n      charCode;\n\n  while (index--) {\n    charCode = charCodeAt.call(string, index);\n    hashA = hashA * 33 ^ charCode;\n    hashB = hashB * 33 ^ charCode;\n  }\n\n  return (hashA >>> 0) * 4096 + (hashB >>> 0);\n};\n/**\n * @function getSortedEvent\n *\n * @description\n * get the event object sorted by its properties\n *\n * @param {boolean} bubbles does the event bubble up through the DOM\n * @param {function} alias to stopPropagation\n * @param {boolean} cancelable is the event cancelable\n * @param {boolean} composed can the event bubble across the boundary to shadow DOM\n * @param {HTMLElement} [currentTarget] registered target for the event\n * @param {boolean} defaultPrevented has preventDefault been called on the event\n * @param {string} eventPhase the phase of the event flow being processed\n * @param {boolean} isTrusted was the event initiated by the browser\n * @param {HTMLElement} [target] the target with which the event was dispatched\n * @param {number} timeStamp the time at which the event was created\n * @param {string} type the name of the event\n * @returns {Object} the event object with all properties sorted\n */\n\nexport var getSortedEvent = function getSortedEvent(_ref) {\n  var bubbles = _ref.bubbles,\n      cancelBubble = _ref.cancelBubble,\n      cancelable = _ref.cancelable,\n      composed = _ref.composed,\n      currentTarget = _ref.currentTarget,\n      defaultPrevented = _ref.defaultPrevented,\n      eventPhase = _ref.eventPhase,\n      isTrusted = _ref.isTrusted,\n      returnValue = _ref.returnValue,\n      target = _ref.target,\n      type = _ref.type;\n  return {\n    bubbles: bubbles,\n    cancelBubble: cancelBubble,\n    cancelable: cancelable,\n    composed: composed,\n    currentTarget: currentTarget,\n    defaultPrevented: defaultPrevented,\n    eventPhase: eventPhase,\n    isTrusted: isTrusted,\n    returnValue: returnValue,\n    target: target,\n    type: type\n  };\n};\n/**\n * @function shouldSort\n *\n * @description\n * get the sort result based on the two values to compare\n *\n * @param {string} valueA the first value to compare\n * @param {string} valueB the second value to compare\n * @returns {boolean} should the value be sorted\n */\n\nexport var shouldSort = function shouldSort(valueA, valueB) {\n  return valueA > valueB;\n};\n/**\n * @function shouldSortPair\n *\n * @description\n * get the sort result based on the two pairs to compare\n *\n * @param {Object} pairA the first pair to compare\n * @param {Object} pairB the second pair to compare\n * @returns {boolean} should the value be sorted\n */\n\nexport var shouldSortPair = function shouldSortPair(pairA, pairB) {\n  return shouldSort(pairA[0], pairB[0]);\n};\n/**\n * @function getPrefixedValue\n *\n * @description\n * get the value prefixed by the tag\n *\n * @param {string} tag the object tag\n * @param {any} value the value to stringify\n * @returns {string} the prefixed stringified value\n */\n\nexport var getPrefixedValue = function getPrefixedValue(tag, value) {\n  return tag + \"|\" + value;\n};\n/**\n * @function sort\n *\n * @description\n * sort the array based on the fn passed\n *\n * @param {Array<any>} array the array to sort\n * @param {function} fn the sorting function\n * @returns {Array<any>} the sorted array\n */\n\nexport var sort = function sort(array, fn) {\n  var subIndex, value;\n\n  for (var index = 0; index < array.length; index++) {\n    value = array[index];\n\n    for (subIndex = index - 1; ~subIndex && fn(array[subIndex], value); subIndex--) {\n      array[subIndex + 1] = array[subIndex];\n    }\n\n    array[subIndex + 1] = value;\n  }\n\n  return array;\n};\n/**\n * @function getIterablePairs\n *\n * @description\n * get the pairs in the iterable for stringification\n *\n * @param {Map|Set} iterable the iterable to get the pairs for\n * @returns {Array<{key: string, value: any}>} the pairs\n */\n\nexport var getSortedIterablePairs = function getSortedIterablePairs(iterable) {\n  var isMap = typeof iterable.get === 'function';\n  var pairs = [];\n  iterable.forEach(function (value, key) {\n    // eslint-disable-next-line no-use-before-define\n    pairs.push(isMap ? [stringify(key), stringify(value)] : [stringify(value)]);\n  });\n  sort(pairs, shouldSortPair);\n  var finalPairs = new Array(iterable.size);\n  var pair;\n\n  for (var index = 0; index < iterable.size; index++) {\n    pair = pairs[index];\n    finalPairs[index] = isMap ? \"[\" + pair[0] + \",\" + pair[1] + \"]\" : pair[0];\n  }\n\n  return getPrefixedValue(getFunctionName(iterable.constructor), \"[\" + finalPairs.join(',') + \"]\");\n};\n/**\n * @function getSortedObject\n *\n * @description\n * get the object with the keys sorted\n *\n * @param {Object} object the object to sort\n * @returns {Object} the sorted object\n */\n\nexport var getSortedObject = function getSortedObject(object) {\n  var objectKeys = sort(keys(object), shouldSort);\n  var newObject = {};\n  var key;\n\n  for (var index = 0; index < objectKeys.length; index++) {\n    key = objectKeys[index];\n    newObject[key] = object[key];\n  }\n\n  return newObject;\n};\n/**\n * @function getStringifiedArrayBufferFallback\n *\n * @description\n * get the string value of the buffer passed based on a Buffer\n *\n * @param {ArrayBuffer} buffer the array buffer to convert\n * @returns {string} the stringified buffer\n */\n\nexport var getStringifiedArrayBufferFallback = function getStringifiedArrayBufferFallback(buffer) {\n  return String.fromCharCode.apply(null, new Uint16Array(buffer));\n};\n/**\n * @function getStringifiedArrayBufferModern\n *\n * @description\n * get the string value of the buffer passed based on a Uint16Array\n *\n * @param {ArrayBuffer} buffer the array buffer to convert\n * @returns {string} the stringified buffer\n */\n\nexport var getStringifiedArrayBufferModern = function getStringifiedArrayBufferModern(buffer) {\n  return Buffer.from(buffer).toString('utf8');\n};\n/**\n * @function getStringifiedArrayBufferNoSupport\n *\n * @description\n * return a placeholder when no arraybuffer support exists\n *\n * @returns {string} the placeholder\n */\n\nexport var getStringifiedArrayBufferNoSupport = function getStringifiedArrayBufferNoSupport() {\n  return '';\n};\n/**\n * @function getStringifiedArrayBuffer\n *\n * @description\n * get the string value of the buffer passed\n *\n * @param {ArrayBuffer} buffer the array buffer to convert\n * @returns {string} the stringified buffer\n */\n\nexport var getStringifiedArrayBuffer = function () {\n  if (HAS_BUFFER_FROM_SUPPORT) {\n    return getStringifiedArrayBufferModern;\n  }\n\n  if (HAS_UINT16ARRAY_SUPPORT) {\n    return getStringifiedArrayBufferFallback;\n  }\n\n  return getStringifiedArrayBufferNoSupport;\n}();\n/**\n * @function getStringifiedDocumentFragment\n *\n * @description\n * build a string based on all the fragment's children\n *\n * @param {DocumentFragment} fragment the fragment to stringify\n * @returns {string} the stringified fragment\n */\n\nexport var getStringifiedDocumentFragment = function getStringifiedDocumentFragment(fragment) {\n  var children = fragment.children;\n  var innerHTML = '';\n\n  for (var index = 0; index < children.length; index++) {\n    innerHTML += children[index].outerHTML;\n  }\n\n  return innerHTML;\n};\n/**\n * @function indexOf\n *\n * @description\n * get the index of the value in the array (faster than native indexOf)\n *\n * @param {Array<any>} array the array to get the index of the value at\n * @param {any} value the value to match\n * @returns {number} the index of the value in array\n */\n\nexport var indexOf = function indexOf(array, value) {\n  for (var index = 0; index < array.length; index++) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n\n  return -1;\n};\n/**\n * @function getNormalizedValue\n *\n * @description\n * get the value normalized for stringification\n *\n * @param {any} value the value to normalize\n * @param {WeakMap|Object} sortedCache the cache of sorted objects\n * @param {string} [passedTag] the previously-calculated tag\n * @returns {any} the normalized value\n */\n\nexport var getNormalizedValue = function getNormalizedValue(value, sortedCache, passedTag) {\n  if (passedTag === void 0) {\n    var type = typeof value;\n\n    if (type === 'string') {\n      return value;\n    }\n\n    if (PRIMITIVE_TAGS[type]) {\n      return getPrefixedValue(type, value);\n    }\n\n    if (value === null) {\n      return getPrefixedValue('null', value);\n    }\n  }\n\n  var tag = passedTag || toString.call(value);\n\n  if (SELF_TAGS[tag]) {\n    return value;\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.OBJECT) {\n    if (~indexOf(sortedCache, value)) {\n      return CIRCULAR_VALUE;\n    }\n\n    sortedCache.push(value);\n    return getSortedObject(value, sortedCache);\n  }\n\n  if (TOSTRING_TAGS[tag]) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.toString());\n  }\n\n  if (ITERABLE_TAGS[tag]) {\n    if (~indexOf(sortedCache, value)) {\n      return CIRCULAR_VALUE;\n    }\n\n    sortedCache.push(value);\n    return getSortedIterablePairs(value);\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.DATE) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.getTime());\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.ERROR) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.stack);\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.EVENT) {\n    return getSortedEvent(value);\n  }\n\n  if (UNPARSEABLE_TAGS[tag]) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], 'NOT_ENUMERABLE');\n  }\n\n  if (HTML_ELEMENT_REGEXP.test(tag) || SVG_ELEMENT_REGEXP.test(tag)) {\n    return getPrefixedValue(tag.slice(8, -1), value.outerHTML);\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.DOCUMENTFRAGMENT) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedDocumentFragment(value));\n  }\n\n  if (TYPEDARRAY_TAGS[tag]) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.join(','));\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.ARRAYBUFFER) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedArrayBuffer(value));\n  }\n\n  if (tag === OBJECT_CLASS_TYPE_MAP.DATAVIEW) {\n    return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedArrayBuffer(value.buffer));\n  }\n\n  return value;\n};\n/**\n * @function replacer\n *\n * @description\n * create the replacer function used for stringification\n *\n * @param {WeakSet|Object} sortedCache the cache to use for sorting objects\n * @returns {function(key: string, value: any)} function getting the normalized value\n */\n\nexport var createReplacer = function createReplacer(sortedCache) {\n  return function (key, value) {\n    return getNormalizedValue(value, sortedCache);\n  };\n};\n/**\n * @function stringify\n *\n * @description\n * stringify the value based on the options passed\n *\n * @param {any} value the value to stringify\n * @returns {string} the stringified value\n */\n\nexport function stringify(value) {\n  if (!value || typeof value !== 'object') {\n    return getNormalizedValue(value);\n  }\n\n  var tag = toString.call(value);\n  return tag === OBJECT_CLASS_TYPE_MAP.DATE || tag === OBJECT_CLASS_TYPE_MAP.REGEXP ? getNormalizedValue(value, void 0, tag) : fastStringify(value, createReplacer([]), null, getCircularValue);\n}","map":null,"metadata":{},"sourceType":"module"}
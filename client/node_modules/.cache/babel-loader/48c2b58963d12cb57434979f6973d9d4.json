{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.curriable = {}));\n})(this, function (exports) {\n  'use strict';\n  /**\r\n   * @constant __ placeholder used when parameters are skipped\r\n   */\n\n  var __ = typeof Symbol === 'function' ? Symbol('curriable placeholder') : 0xedd1;\n  /**\r\n   * @function recursiveCurry\r\n   *\r\n   * @description\r\n   * recursively curry over the arguments until all have been resolved\r\n   *\r\n   * @param fn the function to curry\r\n   * @param arity the length of the function to curry until\r\n   * @param args the existing arguments\r\n   * @returns the result of the function call\r\n   */\n\n\n  var recursiveCurry = function recursiveCurry(fn, arity, args) {\n    return function () {\n      var length = args.length;\n      var newArgs = arguments;\n      var newArgsLength = newArgs.length;\n      var combined = [];\n      var newArgsIndex = 0;\n      var remaining = arity;\n      var value;\n\n      if (length) {\n        for (var index = 0; index < length; index++) {\n          combined[index] = value = args[index] === __ && newArgsIndex < newArgsLength ? newArgs[newArgsIndex++] : args[index];\n\n          if (value !== __) {\n            --remaining;\n          }\n        }\n      }\n\n      if (newArgsIndex < newArgsLength) {\n        for (; newArgsIndex < newArgsLength; newArgsIndex++) {\n          combined[combined.length] = value = newArgs[newArgsIndex];\n\n          if (value !== __ && newArgsIndex < arity) {\n            --remaining;\n          }\n        }\n      }\n\n      return remaining > 0 ? recursiveCurry(fn, arity, combined) : fn.apply(this, combined);\n    };\n  }; // utils\n\n  /**\r\n   * @function curry\r\n   *\r\n   * @description\r\n   * get the method passed as a curriable method based on its parameters\r\n   *\r\n   * @param fn the method to make curriable\r\n   * @param arity the arity of the curried method\r\n   * @returns the fn passed as a curried function\r\n   */\n\n\n  var curry = function curry(fn, arity) {\n    if (arity === void 0) {\n      arity = fn.length;\n    }\n\n    var curried = recursiveCurry(fn, arity, []);\n    curried.arity = arity;\n    curried.fn = fn;\n    return curried;\n  };\n\n  curry.__ = __;\n  /**\r\n   * @function uncurry\r\n   *\r\n   * @description\r\n   * return a function that is the non-curried version of the fn passed\r\n   *\r\n   * @param curried the curried function to uncurry\r\n   * @returns the original fn\r\n   */\n\n  var uncurry = function uncurry(curried) {\n    return curried.fn;\n  };\n\n  curry.uncurry = uncurry;\n  exports.__ = __;\n  exports.curry = curry;\n  exports.uncurry = uncurry;\n  exports.default = curry;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}